// Code generated by codegen. DO NOT EDIT.

package v1beta

import (
	"context"
	"time"

	v1beta "github.com/kraudcloud/wga/apis/wga.kraudcloud.com/v1beta"
	"github.com/rancher/lasso/pkg/client"
	"github.com/rancher/lasso/pkg/controller"
	"github.com/rancher/wrangler/pkg/generic"
	"k8s.io/apimachinery/pkg/api/equality"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
	"k8s.io/apimachinery/pkg/watch"
	"k8s.io/client-go/tools/cache"
)

type WireguardAccessRuleHandler func(string, *v1beta.WireguardAccessRule) (*v1beta.WireguardAccessRule, error)

type WireguardAccessRuleController interface {
	generic.ControllerMeta
	WireguardAccessRuleClient

	OnChange(ctx context.Context, name string, sync WireguardAccessRuleHandler)
	OnRemove(ctx context.Context, name string, sync WireguardAccessRuleHandler)
	Enqueue(name string)
	EnqueueAfter(name string, duration time.Duration)

	Cache() WireguardAccessRuleCache
}

type WireguardAccessRuleClient interface {
	Create(*v1beta.WireguardAccessRule) (*v1beta.WireguardAccessRule, error)
	Update(*v1beta.WireguardAccessRule) (*v1beta.WireguardAccessRule, error)

	Delete(name string, options *metav1.DeleteOptions) error
	Get(name string, options metav1.GetOptions) (*v1beta.WireguardAccessRule, error)
	List(opts metav1.ListOptions) (*v1beta.WireguardAccessRuleList, error)
	Watch(opts metav1.ListOptions) (watch.Interface, error)
	Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *v1beta.WireguardAccessRule, err error)
}

type WireguardAccessRuleCache interface {
	Get(name string) (*v1beta.WireguardAccessRule, error)
	List(selector labels.Selector) ([]*v1beta.WireguardAccessRule, error)

	AddIndexer(indexName string, indexer WireguardAccessRuleIndexer)
	GetByIndex(indexName, key string) ([]*v1beta.WireguardAccessRule, error)
}

type WireguardAccessRuleIndexer func(obj *v1beta.WireguardAccessRule) ([]string, error)

type wireguardAccessRuleController struct {
	controller    controller.SharedController
	client        *client.Client
	gvk           schema.GroupVersionKind
	groupResource schema.GroupResource
}

func NewWireguardAccessRuleController(gvk schema.GroupVersionKind, resource string, namespaced bool, controller controller.SharedControllerFactory) WireguardAccessRuleController {
	c := controller.ForResourceKind(gvk.GroupVersion().WithResource(resource), gvk.Kind, namespaced)
	return &wireguardAccessRuleController{
		controller: c,
		client:     c.Client(),
		gvk:        gvk,
		groupResource: schema.GroupResource{
			Group:    gvk.Group,
			Resource: resource,
		},
	}
}

func FromWireguardAccessRuleHandlerToHandler(sync WireguardAccessRuleHandler) generic.Handler {
	return func(key string, obj runtime.Object) (ret runtime.Object, err error) {
		var v *v1beta.WireguardAccessRule
		if obj == nil {
			v, err = sync(key, nil)
		} else {
			v, err = sync(key, obj.(*v1beta.WireguardAccessRule))
		}
		if v == nil {
			return nil, err
		}
		return v, err
	}
}

func (c *wireguardAccessRuleController) Updater() generic.Updater {
	return func(obj runtime.Object) (runtime.Object, error) {
		newObj, err := c.Update(obj.(*v1beta.WireguardAccessRule))
		if newObj == nil {
			return nil, err
		}
		return newObj, err
	}
}

func UpdateWireguardAccessRuleDeepCopyOnChange(client WireguardAccessRuleClient, obj *v1beta.WireguardAccessRule, handler func(obj *v1beta.WireguardAccessRule) (*v1beta.WireguardAccessRule, error)) (*v1beta.WireguardAccessRule, error) {
	if obj == nil {
		return obj, nil
	}

	copyObj := obj.DeepCopy()
	newObj, err := handler(copyObj)
	if newObj != nil {
		copyObj = newObj
	}
	if obj.ResourceVersion == copyObj.ResourceVersion && !equality.Semantic.DeepEqual(obj, copyObj) {
		return client.Update(copyObj)
	}

	return copyObj, err
}

func (c *wireguardAccessRuleController) AddGenericHandler(ctx context.Context, name string, handler generic.Handler) {
	c.controller.RegisterHandler(ctx, name, controller.SharedControllerHandlerFunc(handler))
}

func (c *wireguardAccessRuleController) AddGenericRemoveHandler(ctx context.Context, name string, handler generic.Handler) {
	c.AddGenericHandler(ctx, name, generic.NewRemoveHandler(name, c.Updater(), handler))
}

func (c *wireguardAccessRuleController) OnChange(ctx context.Context, name string, sync WireguardAccessRuleHandler) {
	c.AddGenericHandler(ctx, name, FromWireguardAccessRuleHandlerToHandler(sync))
}

func (c *wireguardAccessRuleController) OnRemove(ctx context.Context, name string, sync WireguardAccessRuleHandler) {
	c.AddGenericHandler(ctx, name, generic.NewRemoveHandler(name, c.Updater(), FromWireguardAccessRuleHandlerToHandler(sync)))
}

func (c *wireguardAccessRuleController) Enqueue(name string) {
	c.controller.Enqueue("", name)
}

func (c *wireguardAccessRuleController) EnqueueAfter(name string, duration time.Duration) {
	c.controller.EnqueueAfter("", name, duration)
}

func (c *wireguardAccessRuleController) Informer() cache.SharedIndexInformer {
	return c.controller.Informer()
}

func (c *wireguardAccessRuleController) GroupVersionKind() schema.GroupVersionKind {
	return c.gvk
}

func (c *wireguardAccessRuleController) Cache() WireguardAccessRuleCache {
	return &wireguardAccessRuleCache{
		indexer:  c.Informer().GetIndexer(),
		resource: c.groupResource,
	}
}

func (c *wireguardAccessRuleController) Create(obj *v1beta.WireguardAccessRule) (*v1beta.WireguardAccessRule, error) {
	result := &v1beta.WireguardAccessRule{}
	return result, c.client.Create(context.TODO(), "", obj, result, metav1.CreateOptions{})
}

func (c *wireguardAccessRuleController) Update(obj *v1beta.WireguardAccessRule) (*v1beta.WireguardAccessRule, error) {
	result := &v1beta.WireguardAccessRule{}
	return result, c.client.Update(context.TODO(), "", obj, result, metav1.UpdateOptions{})
}

func (c *wireguardAccessRuleController) Delete(name string, options *metav1.DeleteOptions) error {
	if options == nil {
		options = &metav1.DeleteOptions{}
	}
	return c.client.Delete(context.TODO(), "", name, *options)
}

func (c *wireguardAccessRuleController) Get(name string, options metav1.GetOptions) (*v1beta.WireguardAccessRule, error) {
	result := &v1beta.WireguardAccessRule{}
	return result, c.client.Get(context.TODO(), "", name, result, options)
}

func (c *wireguardAccessRuleController) List(opts metav1.ListOptions) (*v1beta.WireguardAccessRuleList, error) {
	result := &v1beta.WireguardAccessRuleList{}
	return result, c.client.List(context.TODO(), "", result, opts)
}

func (c *wireguardAccessRuleController) Watch(opts metav1.ListOptions) (watch.Interface, error) {
	return c.client.Watch(context.TODO(), "", opts)
}

func (c *wireguardAccessRuleController) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (*v1beta.WireguardAccessRule, error) {
	result := &v1beta.WireguardAccessRule{}
	return result, c.client.Patch(context.TODO(), "", name, pt, data, result, metav1.PatchOptions{}, subresources...)
}

type wireguardAccessRuleCache struct {
	indexer  cache.Indexer
	resource schema.GroupResource
}

func (c *wireguardAccessRuleCache) Get(name string) (*v1beta.WireguardAccessRule, error) {
	obj, exists, err := c.indexer.GetByKey(name)
	if err != nil {
		return nil, err
	}
	if !exists {
		return nil, errors.NewNotFound(c.resource, name)
	}
	return obj.(*v1beta.WireguardAccessRule), nil
}

func (c *wireguardAccessRuleCache) List(selector labels.Selector) (ret []*v1beta.WireguardAccessRule, err error) {

	err = cache.ListAll(c.indexer, selector, func(m interface{}) {
		ret = append(ret, m.(*v1beta.WireguardAccessRule))
	})

	return ret, err
}

func (c *wireguardAccessRuleCache) AddIndexer(indexName string, indexer WireguardAccessRuleIndexer) {
	utilruntime.Must(c.indexer.AddIndexers(map[string]cache.IndexFunc{
		indexName: func(obj interface{}) (strings []string, e error) {
			return indexer(obj.(*v1beta.WireguardAccessRule))
		},
	}))
}

func (c *wireguardAccessRuleCache) GetByIndex(indexName, key string) (result []*v1beta.WireguardAccessRule, err error) {
	objs, err := c.indexer.ByIndex(indexName, key)
	if err != nil {
		return nil, err
	}
	result = make([]*v1beta.WireguardAccessRule, 0, len(objs))
	for _, obj := range objs {
		result = append(result, obj.(*v1beta.WireguardAccessRule))
	}
	return result, nil
}
